
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)
from config import BOT_TOKEN
from db import (
    init_db, insert_certificate, grant_access, revoke_access,
    get_shared_with, has_view_access, get_certificates_for_user, get_certificates_shared_with
)
from cert_parser import parse_certificate
from utils import extract_zip, is_certificate_file
import os
import tempfile
import sqlite3
from datetime import datetime

init_db()

def main_menu_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            ["üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç", "üìÑ –ú–æ–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã"],
            ["üîç –ü–æ–∏—Å–∫ –ø–æ —Ñ–∏—Ä–º–µ", "üëÅ –î–æ—Å—Ç—É–ø—ã"]
        ],
        resize_keyboard=True
    )

def access_menu_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üì§ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è", callback_data="share"),
            InlineKeyboardButton("üö´ –û—Ç–æ–∑–≤–∞—Ç—å", callback_data="unshare"),
        ],
        [
            InlineKeyboardButton("üìã –ö–æ–º—É –æ—Ç–∫—Ä—ã—Ç –¥–æ—Å—Ç—É–ø", callback_data="shared_list")
        ]
    ])

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø RemCertBot. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu_keyboard())

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    document = update.message.document

    with tempfile.TemporaryDirectory() as tmpdir:
        file_path = os.path.join(tmpdir, document.file_name)
        tg_file = await document.get_file()
        await tg_file.download_to_drive(file_path)

        cert_paths = []
        if document.file_name.lower().endswith(".zip"):
            extract_zip(file_path, tmpdir)
            for root, _, files in os.walk(tmpdir):
                for name in files:
                    if is_certificate_file(name):
                        cert_paths.append(os.path.join(root, name))
        elif is_certificate_file(document.file_name):
            cert_paths.append(file_path)
        else:
            await update.message.reply_text("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.")
            return

        added = 0
        skipped = 0
        for cert_path in cert_paths:
            try:
                cert = parse_certificate(cert_path)
                filename = os.path.basename(cert_path)
                if insert_certificate(cert, user_id, filename):
                    added += 1
                else:
                    skipped += 1
            except Exception as e:
                await update.message.reply_text(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")
        await update.message.reply_text(f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {added}, –ü—Ä–æ–ø—É—â–µ–Ω–æ: {skipped}")

async def certs_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    from db import get_certificates_for_user, get_certificates_shared_with

    own = get_certificates_for_user(user_id)
    shared = get_certificates_shared_with(user_id)

    if not own and not shared:
        await update.message.reply_text("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤.")
        return

    lines = ["üìÑ –í–∞—à–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã:"]
    idx = 1

    if own:
        lines.append("\nüóÇ *–°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ:*")
        for org, director, valid_to in own:
            try:
                valid_date = datetime.fromisoformat(valid_to).strftime("%d.%m.%Y")
            except:
                valid_date = valid_to
            lines.append(
                f"{idx}. *{org}*\n   üë§ {director}\n   ‚è≥ –î–æ: {valid_date}"
            )
            idx += 1

    if shared:
        lines.append("\nüîó *–î–æ—Å—Ç—É–ø–Ω—ã–µ –æ—Ç –¥—Ä—É–≥–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:*")
        for org, director, valid_to in shared:
            try:
                valid_date = datetime.fromisoformat(valid_to).strftime("%d.%m.%Y")
            except:
                valid_date = valid_to
            lines.append(
                f"{idx}. *{org}*\n   üë§ {director}\n   ‚è≥ –î–æ: {valid_date}"
            )
            idx += 1

    await update.message.reply_text("\n\n".join(lines), parse_mode="Markdown")

async def handle_text_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç":
        await update.message.reply_text("üìé –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –∏–ª–∏ –∞—Ä—Ö–∏–≤ .zip.")
    elif text == "üìÑ –ú–æ–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã":
        await certs_cmd(update, context)
    elif text == "üîç –ü–æ–∏—Å–∫ –ø–æ —Ñ–∏—Ä–º–µ":
        await update.message.reply_text("üîé –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É: /firm <–Ω–∞–∑–≤–∞–Ω–∏–µ>")
    elif text == "üëÅ –î–æ—Å—Ç—É–ø—ã":
        await update.message.reply_text("üîê –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–æ–º:", reply_markup=access_menu_keyboard())

async def share_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    owner_id = update.effective_user.id
    if not context.args:
        await update.message.reply_text("‚ùó –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /share <user_id>")
        return
    try:
        viewer_id = int(context.args[0])
        grant_access(owner_id, viewer_id)
        await update.message.reply_text(f"‚úÖ –î–æ—Å—Ç—É–ø –æ—Ç–∫—Ä—ã—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {viewer_id}.")
    except:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID.")

async def unshare_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    owner_id = update.effective_user.id
    if not context.args:
        await update.message.reply_text("‚ùó –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unshare <user_id>")
        return
    try:
        viewer_id = int(context.args[0])
        revoke_access(owner_id, viewer_id)
        await update.message.reply_text(f"üö´ –î–æ—Å—Ç—É–ø –¥–ª—è {viewer_id} —É–¥–∞–ª—ë–Ω.")
    except:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π ID.")

async def shared_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    owner_id = update.effective_user.id
    viewers = get_shared_with(owner_id)
    if not viewers:
        await update.message.reply_text("üîí –í—ã –Ω–∏ —Å –∫–µ–º –Ω–µ –¥–µ–ª–∏—Ç–µ—Å—å —Å–≤–æ–∏–º–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞–º–∏.")
    else:
        await update.message.reply_text("üì§ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã: " + "\n".join(str(u) for u in viewers))

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    if query.data == "share":
        await query.edit_message_text("‚úâÔ∏è –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /share <user_id>, —á—Ç–æ–±—ã –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –¥–æ—Å—Ç—É–ø–æ–º.")
    elif query.data == "unshare":
        await query.edit_message_text("üßπ –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /unshare <user_id>, —á—Ç–æ–±—ã –æ—Ç–æ–∑–≤–∞—Ç—å –¥–æ—Å—Ç—É–ø.")
    elif query.data == "shared_list":
        shared_ids = get_shared_with(user_id)
        if not shared_ids:
            await query.edit_message_text("üë§ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤ –∏–ª–∏ –¥–æ—Å—Ç—É–ø –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞–ª—Å—è.")
        else:
            lines = ["üîê –î–æ—Å—Ç—É–ø –æ—Ç–∫—Ä—ã—Ç –¥–ª—è:"]
            for uid in shared_ids:
                lines.append(f"‚Ä¢ ID: `{uid}`")
            await query.edit_message_text("\n".join(lines), parse_mode="Markdown")
    else:
        await query.edit_message_text("‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.")

def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("certs", certs_cmd))
    app.add_handler(CommandHandler("share", share_cmd))
    app.add_handler(CommandHandler("unshare", unshare_cmd))
    app.add_handler(CommandHandler("shared", shared_cmd))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_button))
    app.add_handler(MessageHandler(filters.Document.ALL, handle_document))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.run_polling()

if __name__ == "__main__":
    main()
